# A workflow to AUTH with WIF, BUILD the app, RUN the scanner, and PUSH if scan passes
name: '[WIF] Build, Scan, and Push'

on:
  push:
    branches:
      - main
  # --- Define inputs for manual runs ---
  workflow_dispatch:
    inputs:
      IMAGE_NAME_TO_SCAN:
        description: 'The tag for your application image to be built (e.g., my-app)'
        required: true
        default: 'checkout-image'
      GCP_PROJECT_ID:
        description: 'GCP Project ID for authentication and configuration'
        required: true
        default: 'cispoc'
      AR_REPOSITORY: # <--- ADDED FOR PUSHING
        description: 'Artifact Registry repository name (e.g., my-app-repo)'
        required: true
        default: 'demo-images'
      ORGANIZATION_ID:
        description: 'Your GCP Organization ID'
        required: true
        default: '714470867684'
      CONNECTOR_ID:
        description: 'The ID for your pipeline connector'
        required: true
        default: 'organizations/714470867684/locations/global/connectors/testing-demo-jenkins'
      SCANNER_IMAGE:
        description: 'The full registry path for your PRE-BUILT scanner tool'
        required: true
        default: 'us-central1-docker.pkg.dev/ci-plugin/ci-images/scc-artifactguard-scan-image:latest'
      IMAGE_TAG:
        description: 'The Docker image version (of the app image)'
        required: true
        default: 'latest'
      IGNORE_SERVER_ERRORS:
        description: 'If true, the pipeline continues on server/internal scanner errors.'
        required: false
        type: boolean
        default: false
      VERBOSITY:
        description: 'Verbosity flag'
        required: false
        default: 'HIGH'

jobs:
  build-scan-push:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write' # Required for WIF

    # --- Define default environment variables for non-manual runs (like push) ---
    env:
      IMAGE_NAME_TO_SCAN: 'checkout-image'
      GCP_PROJECT_ID: 'cispoc'
      AR_REPOSITORY: 'my-app-repo'
      ORGANIZATION_ID: '714470867684'
      CONNECTOR_ID: 'organizations/714470867684/locations/global/connectors/privatepreviewdemo'
      SCANNER_IMAGE: 'us-central1-docker.pkg.dev/ci-plugin/ci-images/scc-artifactguard-scan-image:latest'
      IMAGE_TAG: 'latest'
      IGNORE_SERVER_ERRORS: 'false'
      VERBOSITY: 'HIGH'

    steps:
      # Step 1: Check out repository (for your app's Dockerfile) <--- NEW
      - name: Check out repository
        uses: actions/checkout@v4

      # Step 2: Authenticate and create credential file (WIF)
      - name: 'Authenticate to Google Cloud'
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true # This creates the file for the scan step

      # Step 3: Set up gcloud SDK
      - name: 'Set up gcloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'
        with:
          project_id: ${{ inputs.GCP_PROJECT_ID }} # Use input for consistency

      # Step 4: Configure Docker for Artifact Registry <--- MODIFIED
      - name: 'Configure Docker for Artifact Registry'
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev --quiet

      # Step 5: Build Application Image Locally <--- NEW
      - name: Build Application Image Locally
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false  # <-- Do not push yet
          load: true   # <-- Load image into the runner's local daemon
          tags: |
            ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_NAME_TO_SCAN || env.IMAGE_NAME_TO_SCAN }}:${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_TAG || env.IMAGE_TAG }}
            
      # Step 6: Run Image Analysis Scan and Handle Exit Codes
      - name: 'Run Image Analysis Scan'
        run: |
          echo "📦 Pulling scanner image and running scan..."

          # Determine values: Use manual inputs if available, otherwise use env defaults
          SCANNER_IMAGE="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.SCANNER_IMAGE || env.SCANNER_IMAGE }}"
          GCP_PROJECT_ID="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.GCP_PROJECT_ID || env.GCP_PROJECT_ID }}"
          ORGANIZATION_ID="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ORGANIZATION_ID || env.ORGANIZATION_ID }}"
          IMAGE_NAME="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_NAME_TO_SCAN || env.IMAGE_NAME_TO_SCAN }}"
          IMAGE_TAG="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_TAG || env.IMAGE_TAG }}"
          CONNECTOR_ID="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.CONNECTOR_ID || env.CONNECTOR_ID }}"
          VERBOSITY="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.VERBOSITY || env.VERBOSITY }}"
          IGNORE_ERRORS="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IGNORE_SERVER_ERRORS || (env.IGNORE_SERVER_ERRORS == 'true') }}"

          exit_code=0
          
          # Run docker and capture exit code
          # This uses the credentials file created by the WIF 'auth' step
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${{ steps.auth.outputs.credentials_file_path }}:/gcp-creds.json \
            -e GOOGLE_APPLICATION_CREDENTIALS=/gcp-creds.json \
            -e GCP_PROJECT_ID="${GCP_PROJECT_ID}" \
            -e ORGANIZATION_ID="${ORGANIZATION_ID}" \
            -e IMAGE_NAME="${IMAGE_NAME}" \
            -e IMAGE_TAG="${IMAGE_TAG}" \
            -e CONNECTOR_ID="${CONNECTOR_ID}" \
            -e BUILD_TAG="${{ github.workflow }}" \
            -e BUILD_ID="${{ github.run_number }}" \
            -e VERBOSITY="${VERBOSITY}" \
            "${SCANNER_IMAGE}" \
            || exit_code=$?

          echo "Docker run finished with exit code: $exit_code"

          # --- Replicate Jenkins Exit Code Logic ---
          if [ $exit_code -eq 0 ]; then
            echo "✅ Evaluation succeeded: Conformant image."
          elif [ $exit_code -eq 1 ]; then
            echo "❌ Scan failed: Non-conformant image (vulnerabilities found)."
            exit 1 # Fail the step
          else
            if [ "$IGNORE_ERRORS" = "true" ]; then
              echo "⚠️ Server/internal error occurred (Code: $exit_code), but IGNORE_SERVER_ERRORS=true. Proceeding."
            else
              echo "❌ Server/internal error occurred (Code: $exit_code) during evaluation. Set IGNORE_SERVER_ERRORS=true to override."
              exit 1 # Fail the step
            fi
          fi

      # Step 7: Push Application Image (ONLY if scan succeeded) <--- NEW
      # This step only runs if the 'Run Image Analysis Scan' step above exited with 0
      - name: Push Application Image to Artifact Registry
        run: |
          # Get variables again (for this separate step)
          GCP_PROJECT_ID="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.GCP_PROJECT_ID || env.GCP_PROJECT_ID }}"
          AR_REPOSITORY="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.AR_REPOSITORY || env.AR_REPOSITORY }}"
          IMAGE_NAME="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_NAME_TO_SCAN || env.IMAGE_NAME_TO_SCAN }}"
          IMAGE_TAG="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.IMAGE_TAG || env.IMAGE_TAG }}"

          # Define the local and remote tags
          LOCAL_IMAGE_NAME="${IMAGE_NAME}:${IMAGE_TAG}"
          FULL_AR_TAG="us-central1-docker.pkg.dev/${GCP_PROJECT_ID}/${AR_REPOSITORY}/${IMAGE_NAME}:${IMAGE_TAG}"

          echo "Tagging local image ${LOCAL_IMAGE_NAME} as ${FULL_AR_TAG}"
          docker tag "${LOCAL_IMAGE_NAME}" "${FULL_AR_TAG}"
          
          echo "Pushing ${FULL_AR_TAG} to Artifact Registry..."
          docker push "${FULL_AR_TAG}"
